# STM32 LoRaWAN End Node - Bees Charge Monitoring

## System Overview

This firmware implements a **bees charge monitoring system** using an STM32WL LoRaWAN end node with an **analog comparator + ADC** for precise peak detection.

### Charge Monitoring Flow

```
Bee Charge Signal → Comparator Threshold → Interrupt → ADC Acquisition → Peak Buffer → LoRaWAN TX
```


---

## Key Features

- **Analog Comparator**: Triggers interrupt when charge signal exceeds threshold
- **ADC Conversion**: High-speed sampling triggered by comparator
- **Peak Detection Algorithm**:
  - Captures **peak voltage** (16-bit)
  - Records **timestamp delta** (16-bit ms from previous peak)
  - **8-peak buffer** (4 bytes/peak = 32 bytes total)
- **LoRaWAN Transmission**: Buffer sent when full (event-driven)

---

## Data Format

**AppDataBuffer → Peak Buffer (32 bytes):**

```
[Peak1_V | Peak1_Time | Peak2_V | Peak2_Time | ... | Peak8_V | Peak8_Time]
 2B    |   2B      |  2B    |   2B     | ... |  2B    |    2B
```

- Each peak entry is 4 bytes: 2 bytes little-endian voltage, 2 bytes little-endian time delta (ms).
- Total buffer size: **32 bytes** (8 peaks × 4 bytes).

---

## Implementation Details

### Core Components

| File | Modifications |
|------|---------------|
| **`utilities_def.h`** | Added `CFG_SEQ_Task_ADC_Acquisition` task ID |
| **`lora_app.c`** | - `HAL_COMP_TriggerCallback()` comparator ISR  
| | - `UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_ADC_Acquisition), ...)`  
| | - Task registration: `UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_ADC_Acquisition), ...)` |
| **`adc_if.h/c`** | **⚠️ Critical**: Auto-generated by CubeMX |


### ADC Configuration Warning ⚠️

- ❌ **Problem:** Adding ADC channels → CubeMX may skip `adc_if.h/c` generation.
- ✅ **Solution:** In CubeMX go to **Middleware → Platform Settings → Enable "ADC"** to ensure `adc_if.*` gets generated.

---

## Peak Acquisition Function (`acquirePeak()`)

```c
static void acquirePeak(void)
{
    static uint16_t peakBuffer; // 8 peaks × (2B voltage + 2B time)
    static uint8_t bufferIndex = 0;
    static uint32_t lastPeakTime = 0;

    while (bufferIndex < 16) {
        // Poll ADC for peak detection
        uint16_t adcValue = readADC();  // 12-bit → 16-bit safe

        if (isPeakDetected(adcValue)) {
            uint16_t peakVoltage = adcValue;
            uint16_t timeDelta = (HAL_GetTick() - lastPeakTime);

            // Store in AppDataBuffer (little-endian)
            AppDataBuffer[bufferIndex++] = (peakVoltage & 0xFF);
            AppDataBuffer[bufferIndex++] = (peakVoltage >> 8);
            AppDataBuffer[bufferIndex++] = (timeDelta & 0xFF);
            AppDataBuffer[bufferIndex++] = (timeDelta >> 8);

            lastPeakTime = HAL_GetTick();
        }

        // Buffer full → trigger transmission
        if (bufferIndex >= 32) {
            AppData.BufferSize = 32;
            UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
            bufferIndex = 0;
            return;
        }
    }
}
```

> Notes:
> - `adcValue` is captured as a 12-bit ADC result but stored safely into 16-bit fields.
> - Time delta is computed in milliseconds using `HAL_GetTick()` and stored as a 16-bit value. Ensure your maximum inter-peak interval fits within 16-bit (65535 ms ≈ 65.5 s).

---

## ⚠️ Transmission Configuration

- ❌ **DEFAULT:** Timer-based TX (every X ms)
- ✅ **REQUIRED:** Event-based TX (buffer full only)

**Fix (in `lora_app.c` → `OnTxTimerEvent()`):**

```c
// Comment out this line after CubeMX generation:
UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
```

- The above disables automatic timer-driven uplinks and ensures uplinks are only triggered by the buffer being full (event-driven).

---

## Hardware Connections

- **Bee Charge Sensor** → Analog Input → Comparator+ → Threshold (DAC/VREF)
- Comparator output (**COMP_OUT**) → EXTI (interrupt)
- ADC Channel → Peak Sampling

Block flow:

```
Bee Charge Sensor
    ↓
Analog Input → Comparator+ (Threshold via DAC/VREF)
    ↓
COMP_OUT → EXTI (interrupt)
    ↓
Trigger ADC channel for peak sampling
```

---

## Buffer Transmission Trigger

1. Peak Buffer Full (8 peaks) → `AppData.BufferSize = 32`
2. `LmHandlerSend(AppData, ...)` → LoRaWAN Uplink (Port customizable)

---

## Integration Checklist

- [ ] Add `CFG_SEQ_Task_ADC_Acquisition` to `utilities_def.h` with a unique task ID.
- [ ] Register the ADC acquisition task with `UTIL_SEQ_RegTask(...)` in `lora_app.c` initialization.
- [ ] Implement `HAL_COMP_TriggerCallback()` to call `UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_ADC_Acquisition), ...)`.
- [ ] Ensure CubeMX generates `adc_if.h/c` by enabling ADC in Platform Settings.
- [ ] Disable timer-based TX in `OnTxTimerEvent()` to make TX event-driven when the buffer is full.
- [ ] Verify `AppDataBuffer` is little-endian and `AppData.BufferSize` is set to 32 before sending.
- [ ] Make sure time delta fits into 16 bits or adjust encoding if longer intervals are expected.

---

## Troubleshooting

- **Missing `adc_if.h/c` after adding ADC channels in CubeMX**: See ADC Configuration Warning above — enable ADC under Middleware → Platform Settings.
- **Unexpected periodic uplinks**: Ensure the timer-based trigger in `OnTxTimerEvent()` is commented out and only buffer-full events trigger a send.
- **Peak timings overflowing 16-bit**: If you expect gaps larger than ~65 s between peaks, store time deltas in 32-bit or use a different encoding scheme.

---

## Appendix

### Suggested LoRaWAN Send Call

When buffer is full and `AppData.BufferSize` is set, use the project’s LoRaWAN send handler, for example:

```c
LmHandlerSend(&AppData, ...);
```

- Adjust port and confirm duty-cycle/regional parameters as required by your LoRaWAN stack and region.

---

*If you want this as a single file (e.g., `BEES_Charge_Monitoring.md`) prepared for direct commit to your wiki repo, tell me and I can export it as a markdown file.*

